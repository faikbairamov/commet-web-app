from flask import Flask, jsonify, request, session, redirect, url_for
from flask_cors import CORS
import os
from github import Github
from datetime import datetime
from ai_service import GitHubAIService
from github_auth import GitHubAuthService
from integrations.project_management.jira import JiraIntegration
from webhooks.jira_webhooks import JiraWebhookHandler
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv('FLASK_SECRET_KEY', 'dev-secret-key-change-in-production')

# Enable CORS for frontend
allowed_origins = [
    'http://localhost:5173', 
    'http://localhost:5174',
    'https://commet-web-app-production.up.railway.app',
    'https://commet-web-app-frontend-production.up.railway.app'
]

# Add Railway frontend URL if provided
frontend_url = os.getenv('FRONTEND_URL')
if frontend_url:
    allowed_origins.append(frontend_url)

CORS(app, origins=allowed_origins, supports_credentials=True)

# Initialize services
try:
    ai_service = GitHubAIService()
    print("✅ AI service initialized successfully")
except ValueError as e:
    print(f"⚠️  AI service not available: {e}")
    ai_service = None

try:
    github_auth = GitHubAuthService()
except Exception as e:
    print(f"⚠️  GitHub Auth service not available: {e}")
    github_auth = None

# Initialize Jira integration
try:
    jira_config = {
        'base_url': os.getenv('JIRA_URL'),
        'email': os.getenv('JIRA_EMAIL'),
        'api_token': os.getenv('JIRA_API_TOKEN'),
        'project_key': os.getenv('JIRA_PROJECT_KEY'),
        'enabled': bool(os.getenv('JIRA_URL') and os.getenv('JIRA_EMAIL') and os.getenv('JIRA_API_TOKEN'))
    }
    jira_integration = JiraIntegration(jira_config) if jira_config['enabled'] else None
    if jira_integration:
        print("✅ Jira integration initialized successfully")
        # Check auto-ticket creation settings
        auto_create_tickets = os.getenv('JIRA_AUTO_CREATE_TICKETS', 'true').lower() == 'true'
        if auto_create_tickets:
            print("✅ Auto-ticket creation enabled")
        else:
            print("⚠️  Auto-ticket creation disabled (set JIRA_AUTO_CREATE_TICKETS=true to enable)")
    else:
        print("⚠️  Jira integration not configured (missing environment variables)")
except Exception as e:
    print(f"⚠️  Jira integration not available: {e}")
    jira_integration = None

# Initialize Jira webhook handler
jira_webhook_handler = JiraWebhookHandler(jira_integration) if jira_integration else None

# Basic route
@app.route('/')
def home():
    return jsonify({
        "message": "Welcome to the Python Server!",
        "status": "running",
        "port": 3000
    })

# Health check endpoint
@app.route('/health')
def health():
    return jsonify({
        "status": "healthy",
        "message": "Server is running properly"
    })

# Example API endpoint
@app.route('/api/users', methods=['GET'])
def get_users():
    # Sample data
    users = [
        {"id": 1, "name": "John Doe", "email": "john@example.com"},
        {"id": 2, "name": "Jane Smith", "email": "jane@example.com"},
        {"id": 3, "name": "Bob Johnson", "email": "bob@example.com"}
    ]
    return jsonify({"users": users})

# Example POST endpoint
@app.route('/api/users', methods=['POST'])
def create_user():
    data = request.get_json()
    if not data or 'name' not in data or 'email' not in data:
        return jsonify({"error": "Name and email are required"}), 400
    
    # In a real application, you would save this to a database
    new_user = {
        "id": 4,  # This would be generated by the database
        "name": data['name'],
        "email": data['email']
    }
    
    return jsonify({"message": "User created successfully", "user": new_user}), 201

# Git commits endpoint using PyGithub
@app.route('/api/git/commits', methods=['GET'])
def get_git_commits():
    """
    Fetch git commits from a GitHub repository using PyGithub.
    Supported parameter combinations:
    1. repo + token + branch + limit
    2. repo + token + limit  
    3. repo + branch + limit
    
    Query parameters:
    - repo: Repository in format 'owner/repo' (required)
    - token: GitHub personal access token (required for combinations 1 & 2)
    - branch: Branch name (required for combinations 1 & 3)
    - limit: Number of commits to fetch (required, max: 100)
    """
    try:
        # Get query parameters
        repo_name = request.args.get('repo')
        limit = request.args.get('limit')
        branch = request.args.get('branch')
        token = request.args.get('token')
        
        # Validate required parameters
        if not repo_name:
            return jsonify({"error": "Repository parameter 'repo' is required (format: 'owner/repo')"}), 400
        
        if not limit:
            return jsonify({"error": "Limit parameter is required"}), 400
        
        try:
            limit = int(limit)
        except ValueError:
            return jsonify({"error": "Invalid limit parameter. Must be a number."}), 400
        
        if limit > 100:
            limit = 100
        if limit < 1:
            limit = 1
        
        # Validate parameter combinations
        has_token = token is not None
        has_branch = branch is not None
        
        if not has_token and not has_branch:
            return jsonify({"error": "Invalid parameter combination. Must include either 'token' or 'branch' parameter"}), 400
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()  # Use unauthenticated access (rate limited)
        
        # Get repository
        try:
            repo = g.get_repo(repo_name)
        except Exception as e:
            return jsonify({"error": f"Repository not found or not accessible: {str(e)}"}), 404
        
        # Get commits
        try:
            if branch:
                commits = repo.get_commits(sha=branch)
            else:
                commits = repo.get_commits()  # Default branch
            
            commits_list = []
            
            for i, commit in enumerate(commits):
                if i >= limit:
                    break
                
                commit_data = {
                    "sha": commit.sha,
                    "message": commit.commit.message,
                    "author": {
                        "name": commit.commit.author.name,
                        "email": commit.commit.author.email,
                        "date": commit.commit.author.date.isoformat()
                    },
                    "committer": {
                        "name": commit.commit.committer.name,
                        "email": commit.commit.committer.email,
                        "date": commit.commit.committer.date.isoformat()
                    },
                    "url": commit.html_url,
                    "api_url": commit.url,
                    "stats": {
                        "additions": commit.stats.additions if commit.stats else 0,
                        "deletions": commit.stats.deletions if commit.stats else 0,
                        "total": commit.stats.total if commit.stats else 0
                    }
                }
                commits_list.append(commit_data)
            
            return jsonify({
                "repository": repo_name,
                "branch": branch if branch else "default",
                "total_commits": len(commits_list),
                "commits": commits_list
            })
            
        except Exception as e:
            return jsonify({"error": f"Error fetching commits: {str(e)}"}), 500
            
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

# Git commit details with code differences endpoint
@app.route('/api/git/commit-details', methods=['GET'])
def get_commit_details():
    """
    Fetch detailed commit information including code differences (additions/deletions).
    Supported parameter combinations:
    1. repo + token + branch + limit
    2. repo + token + limit  
    3. repo + branch + limit
    
    Query parameters:
    - repo: Repository in format 'owner/repo' (required)
    - token: GitHub personal access token (required for combinations 1 & 2)
    - branch: Branch name (required for combinations 1 & 3)
    - limit: Number of commits to fetch (required, max: 100)
    """
    try:
        # Get query parameters
        repo_name = request.args.get('repo')
        limit = request.args.get('limit')
        branch = request.args.get('branch')
        token = request.args.get('token')
        
        # Validate required parameters
        if not repo_name:
            return jsonify({"error": "Repository parameter 'repo' is required (format: 'owner/repo')"}), 400
        
        if not limit:
            return jsonify({"error": "Limit parameter is required"}), 400
        
        try:
            limit = int(limit)
        except ValueError:
            return jsonify({"error": "Invalid limit parameter. Must be a number."}), 400
        
        if limit > 100:
            limit = 100
        if limit < 1:
            limit = 1
        
        # Validate parameter combinations
        has_token = token is not None
        has_branch = branch is not None
        
        if not has_token and not has_branch:
            return jsonify({"error": "Invalid parameter combination. Must include either 'token' or 'branch' parameter"}), 400
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()  # Use unauthenticated access (rate limited)
        
        # Get repository
        try:
            repo = g.get_repo(repo_name)
        except Exception as e:
            return jsonify({"error": f"Repository not found or not accessible: {str(e)}"}), 404
        
        # Get commits
        try:
            if branch:
                commits = repo.get_commits(sha=branch)
            else:
                commits = repo.get_commits()  # Default branch
            
            commits_list = []
            
            for i, commit in enumerate(commits):
                if i >= limit:
                    break
                
                # Get detailed commit information including file changes
                try:
                    # Get the full commit object with file changes
                    full_commit = repo.get_commit(commit.sha)
                    
                    # Process file changes
                    file_changes = []
                    for file in full_commit.files:
                        file_change = {
                            "filename": file.filename,
                            "status": file.status,  # added, modified, deleted, renamed, etc.
                            "additions": file.additions,
                            "deletions": file.deletions,
                            "changes": file.changes,
                            "patch": file.patch if file.patch else None,  # The actual diff
                            "previous_filename": file.previous_filename if hasattr(file, 'previous_filename') else None
                        }
                        file_changes.append(file_change)
                    
                    commit_data = {
                        "sha": commit.sha,
                        "message": commit.commit.message,
                        "author": {
                            "name": commit.commit.author.name,
                            "email": commit.commit.author.email,
                            "date": commit.commit.author.date.isoformat()
                        },
                        "committer": {
                            "name": commit.commit.committer.name,
                            "email": commit.commit.committer.email,
                            "date": commit.commit.committer.date.isoformat()
                        },
                        "url": commit.html_url,
                        "api_url": commit.url,
                        "stats": {
                            "additions": commit.stats.additions if commit.stats else 0,
                            "deletions": commit.stats.deletions if commit.stats else 0,
                            "total": commit.stats.total if commit.stats else 0
                        },
                        "file_changes": file_changes
                    }
                    commits_list.append(commit_data)
                    
                except Exception as e:
                    # If we can't get detailed info for this commit, skip it
                    print(f"Warning: Could not get details for commit {commit.sha}: {str(e)}")
                    continue
            
            return jsonify({
                "repository": repo_name,
                "branch": branch if branch else "default",
                "total_commits": len(commits_list),
                "commits": commits_list
            })
            
        except Exception as e:
            return jsonify({"error": f"Error fetching commits: {str(e)}"}), 500
            
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

# Repository info endpoint
@app.route('/api/git/repo', methods=['GET'])
def get_repo_info():
    """
    Get basic information about a GitHub repository.
    Query parameters:
    - repo: Repository in format 'owner/repo' (e.g., 'microsoft/vscode')
    - token: GitHub personal access token (optional, for private repos)
    """
    try:
        repo_name = request.args.get('repo')
        token = request.args.get('token')
        
        if not repo_name:
            return jsonify({"error": "Repository parameter 'repo' is required (format: 'owner/repo')"}), 400
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()
        
        # Get repository
        try:
            repo = g.get_repo(repo_name)
        except Exception as e:
            return jsonify({"error": f"Repository not found or not accessible: {str(e)}"}), 404
        
        # Get repository information
        repo_info = {
            "name": repo.name,
            "full_name": repo.full_name,
            "description": repo.description,
            "url": repo.html_url,
            "clone_url": repo.clone_url,
            "ssh_url": repo.ssh_url,
            "language": repo.language,
            "languages": repo.get_languages(),
            "stars": repo.stargazers_count,
            "forks": repo.forks_count,
            "watchers": repo.watchers_count,
            "open_issues": repo.open_issues_count,
            "created_at": repo.created_at.isoformat(),
            "updated_at": repo.updated_at.isoformat(),
            "pushed_at": repo.pushed_at.isoformat() if repo.pushed_at else None,
            "default_branch": repo.default_branch,
            "is_private": repo.private,
            "owner": {
                "login": repo.owner.login,
                "type": repo.owner.type,
                "avatar_url": repo.owner.avatar_url,
                "url": repo.owner.html_url
            }
        }
        
        return jsonify(repo_info)
        
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

def _analyze_and_create_jira_tickets(ai_response, question, repo_data, commits_data, jira_integration):
    """
    Analyze AI response and automatically create Jira tickets for detected issues.
    
    Args:
        ai_response: The AI-generated response text
        question: The original question asked
        repo_data: Repository metadata
        commits_data: List of commits data
        jira_integration: JiraIntegration instance
        
    Returns:
        List of created ticket information
    """
    tickets_created = []
    
    try:
        # Convert response to lowercase for analysis
        response_lower = ai_response.lower()
        
        # Define issue patterns and their corresponding ticket data
        issue_patterns = {
            'security': {
                'keywords': ['security', 'vulnerability', 'injection', 'xss', 'csrf', 'authentication', 'authorization', 'encryption', 'ssl', 'tls', 'cors', 'sql injection', 'cross-site'],
                'severity': 'high',
                'category': 'security',
                'priority': 'High'
            },
            'performance': {
                'keywords': ['performance', 'slow', 'bottleneck', 'memory leak', 'cpu usage', 'optimization', 'efficiency', 'timeout', 'latency'],
                'severity': 'medium',
                'category': 'performance',
                'priority': 'Medium'
            },
            'code_quality': {
                'keywords': ['code quality', 'maintainability', 'readability', 'complexity', 'duplication', 'refactoring', 'technical debt', 'best practices'],
                'severity': 'medium',
                'category': 'code-quality',
                'priority': 'Medium'
            },
            'bug': {
                'keywords': ['bug', 'error', 'exception', 'crash', 'failure', 'issue', 'problem', 'defect', 'malfunction'],
                'severity': 'high',
                'category': 'bug',
                'priority': 'High'
            },
            'documentation': {
                'keywords': ['documentation', 'readme', 'comments', 'api docs', 'missing docs', 'outdated docs'],
                'severity': 'low',
                'category': 'documentation',
                'priority': 'Low'
            }
        }
        
        # Check for each issue type
        for issue_type, config in issue_patterns.items():
            if any(keyword in response_lower for keyword in config['keywords']):
                # Extract relevant information from the response
                issue_title = _extract_issue_title(ai_response, issue_type)
                issue_description = _format_issue_description(ai_response, repo_data, question)
                
                # Create analysis data for Jira ticket
                analysis_data = {
                    'title': issue_title,
                    'severity': config['severity'],
                    'category': config['category'],
                    'description': issue_description,
                    'file_path': 'Multiple files (see analysis)',
                    'line_number': 'N/A',
                    'recommendation': _extract_recommendations(ai_response),
                    'code_snippet': _extract_code_context(ai_response),
                    'quality_score': _estimate_quality_score(ai_response, config['severity']),
                    'repository': repo_data.get('full_name', 'Unknown'),
                    'analysis_question': question
                }
                
                # Create Jira ticket
                try:
                    success = jira_integration.create_quality_ticket(analysis_data)
                    if success:
                        tickets_created.append({
                            'type': issue_type,
                            'title': issue_title,
                            'severity': config['severity'],
                            'priority': config['priority'],
                            'category': config['category'],
                            'status': 'created'
                        })
                        print(f"✅ Created Jira ticket for {issue_type} issue: {issue_title}")
                    else:
                        print(f"❌ Failed to create Jira ticket for {issue_type} issue")
                except Exception as e:
                    print(f"❌ Error creating Jira ticket for {issue_type}: {str(e)}")
        
        # Check for commit-related issues that might need tickets
        if commits_data and any('commit' in response_lower or 'change' in response_lower for _ in [1]):
            _create_commit_analysis_tickets(commits_data, ai_response, repo_data, jira_integration, tickets_created)
        
    except Exception as e:
        print(f"❌ Error in automatic Jira ticket creation: {str(e)}")
    
    return tickets_created

def _extract_issue_title(ai_response, issue_type):
    """Extract a concise title for the issue from AI response."""
    # Look for patterns that might indicate a title
    lines = ai_response.split('\n')
    for line in lines:
        line = line.strip()
        if line and len(line) < 100 and any(word in line.lower() for word in ['issue', 'problem', 'vulnerability', 'bug', 'security']):
            return line
    
    # Fallback to generic title
    return f"AI-Detected {issue_type.replace('_', ' ').title()} Issue"

def _format_issue_description(ai_response, repo_data, question):
    """Format a comprehensive description for the Jira ticket."""
    return f"""
**Commet AI Analysis Report**

**Repository**: {repo_data.get('full_name', 'Unknown')}
**Analysis Question**: {question}
**Language**: {repo_data.get('language', 'Unknown')}
**Analysis Date**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

**AI Analysis Results**:
{ai_response}

**Repository Information**:
- Stars: {repo_data.get('stars', 'N/A')}
- Forks: {repo_data.get('forks', 'N/A')}
- Open Issues: {repo_data.get('open_issues', 'N/A')}
- Last Updated: {repo_data.get('updated_at', 'N/A')}

---
*This ticket was automatically created by Commet AI analysis.*
    """.strip()

def _extract_recommendations(ai_response):
    """Extract recommendations from AI response."""
    lines = ai_response.split('\n')
    recommendations = []
    
    for line in lines:
        line = line.strip()
        if any(word in line.lower() for word in ['recommend', 'suggest', 'should', 'consider', 'improve']):
            recommendations.append(line)
    
    return '\n'.join(recommendations) if recommendations else "See AI analysis for detailed recommendations."

def _extract_code_context(ai_response):
    """Extract code snippets from AI response."""
    lines = ai_response.split('\n')
    code_context = []
    in_code_block = False
    
    for line in lines:
        if '```' in line:
            in_code_block = not in_code_block
            continue
        if in_code_block:
            code_context.append(line)
    
    return '\n'.join(code_context) if code_context else "No specific code context identified."

def _estimate_quality_score(ai_response, severity):
    """Estimate a quality score based on the AI response and severity."""
    base_scores = {
        'high': 30,
        'medium': 60,
        'low': 80
    }
    
    base_score = base_scores.get(severity, 50)
    
    # Adjust based on response content
    if 'critical' in ai_response.lower():
        return max(10, base_score - 20)
    elif 'minor' in ai_response.lower():
        return min(90, base_score + 20)
    
    return base_score

def _create_commit_analysis_tickets(commits_data, ai_response, repo_data, jira_integration, tickets_created):
    """Create tickets for commit-related issues."""
    try:
        # Look for patterns in commit messages that might indicate issues
        problematic_commits = []
        
        for commit in commits_data:
            message = commit.get('message', '').lower()
            if any(word in message for word in ['fix', 'bug', 'issue', 'error', 'hotfix', 'patch']):
                problematic_commits.append(commit)
        
        if problematic_commits and len(problematic_commits) > 3:  # If many fix commits
            analysis_data = {
                'title': 'High Frequency of Bug Fix Commits',
                'severity': 'medium',
                'category': 'code-quality',
                'description': f"""
**Commit Analysis Alert**

**Repository**: {repo_data.get('full_name', 'Unknown')}
**Issue**: High frequency of bug fix commits detected

**Recent Fix Commits**:
{chr(10).join([f"- {commit.get('sha', '')[:8]}: {commit.get('message', '')[:100]}" for commit in problematic_commits[:5]])}

**Analysis**: The repository shows a pattern of frequent bug fixes, which may indicate underlying code quality issues or insufficient testing.

**Recommendation**: Consider implementing better testing practices, code reviews, or refactoring to reduce the frequency of bug fixes.

---
*This ticket was automatically created by Commet commit analysis.*
                """.strip(),
                'file_path': 'Multiple files (commit analysis)',
                'line_number': 'N/A',
                'recommendation': 'Implement better testing and code review practices',
                'code_snippet': 'Commit analysis - see description for details',
                'quality_score': 40,
                'repository': repo_data.get('full_name', 'Unknown')
            }
            
            success = jira_integration.create_quality_ticket(analysis_data)
            if success:
                tickets_created.append({
                    'type': 'commit_analysis',
                    'title': 'High Frequency of Bug Fix Commits',
                    'severity': 'medium',
                    'priority': 'Medium',
                    'category': 'code-quality',
                    'status': 'created'
                })
                print("✅ Created Jira ticket for commit analysis")
    
    except Exception as e:
        print(f"❌ Error creating commit analysis ticket: {str(e)}")

# AI Chat endpoint for GitHub repository analysis
@app.route('/api/chat', methods=['POST'])
def chat_with_repository():
    """
    Answer questions about a GitHub repository using AI analysis.
    
    Request Body:
    {
        "question": "What is the main programming language used in this repository?",
        "repo": "microsoft/vscode",
        "token": "optional_github_token",
        "branch": "optional_branch_name",
        "commits_limit": 10
    }
    
    Supported parameter combinations:
    1. repo + token + branch + commits_limit
    2. repo + token + commits_limit  
    3. repo + branch + commits_limit
    """
    try:
        # Check if AI service is available
        if not ai_service:
            return jsonify({"error": "AI service not available. Please check OPENAI_API_KEY environment variable."}), 503
        
        # Get request data
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        question = data.get('question')
        repo_name = data.get('repo')
        token = data.get('token')
        branch = data.get('branch')
        commits_limit = data.get('commits_limit', 10)
        
        # Validate required parameters
        if not question:
            return jsonify({"error": "Question parameter is required"}), 400
        
        if not repo_name:
            return jsonify({"error": "Repository parameter 'repo' is required (format: 'owner/repo')"}), 400
        
        # Validate parameter combinations
        has_token = token is not None
        has_branch = branch is not None
        
        if not has_token and not has_branch:
            return jsonify({"error": "Invalid parameter combination. Must include either 'token' or 'branch' parameter"}), 400
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()  # Use unauthenticated access (rate limited)
        
        # Get repository information
        try:
            repo = g.get_repo(repo_name)
        except Exception as e:
            return jsonify({"error": f"Repository not found or not accessible: {str(e)}"}), 404
        
        # Get repository metadata
        repo_data = {
            "name": repo.name,
            "full_name": repo.full_name,
            "description": repo.description,
            "url": repo.html_url,
            "language": repo.language,
            "languages": repo.get_languages(),
            "stars": repo.stargazers_count,
            "forks": repo.forks_count,
            "watchers": repo.watchers_count,
            "open_issues": repo.open_issues_count,
            "created_at": repo.created_at.isoformat(),
            "updated_at": repo.updated_at.isoformat(),
            "pushed_at": repo.pushed_at.isoformat() if repo.pushed_at else None,
            "default_branch": repo.default_branch,
            "is_private": repo.private,
            "owner": {
                "login": repo.owner.login,
                "type": repo.owner.type,
                "avatar_url": repo.owner.avatar_url,
                "url": repo.owner.html_url
            }
        }
        
        # Get commits data
        try:
            if branch:
                commits = repo.get_commits(sha=branch)
            else:
                commits = repo.get_commits()  # Default branch
            
            commits_data = []
            for i, commit in enumerate(commits):
                if i >= commits_limit:
                    break
                
                commit_data = {
                    "sha": commit.sha,
                    "message": commit.commit.message,
                    "author": {
                        "name": commit.commit.author.name,
                        "email": commit.commit.author.email,
                        "date": commit.commit.author.date.isoformat()
                    },
                    "committer": {
                        "name": commit.commit.committer.name,
                        "email": commit.commit.committer.email,
                        "date": commit.commit.committer.date.isoformat()
                    },
                    "url": commit.html_url,
                    "stats": {
                        "additions": commit.stats.additions if commit.stats else 0,
                        "deletions": commit.stats.deletions if commit.stats else 0,
                        "total": commit.stats.total if commit.stats else 0
                    }
                }
                
                # Try to get detailed file changes for better analysis
                try:
                    full_commit = repo.get_commit(commit.sha)
                    file_changes = []
                    for file in full_commit.files:
                        file_change = {
                            "filename": file.filename,
                            "status": file.status,
                            "additions": file.additions,
                            "deletions": file.deletions,
                            "changes": file.changes
                        }
                        file_changes.append(file_change)
                    commit_data["file_changes"] = file_changes
                except:
                    # If we can't get file changes, continue without them
                    pass
                
                commits_data.append(commit_data)
        
        except Exception as e:
            return jsonify({"error": f"Error fetching commits: {str(e)}"}), 500
        
        # Use AI service to analyze the data and answer the question
        try:
            ai_response = ai_service.analyze_repository_data(repo_data, commits_data, question)
            
            # Check if Jira integration is available and auto-ticket creation is enabled
            jira_tickets_created = []
            auto_create_enabled = os.getenv('JIRA_AUTO_CREATE_TICKETS', 'true').lower() == 'true'
            if jira_integration and auto_create_enabled and data.get('auto_create_tickets', True):
                jira_tickets_created = _analyze_and_create_jira_tickets(
                    ai_response, question, repo_data, commits_data, jira_integration
                )
            
            response_data = {
                "question": question,
                "repository": repo_name,
                "branch": branch if branch else "default",
                "analysis_data": {
                    "repository_info": repo_data,
                    "commits_analyzed": len(commits_data),
                    "commits_limit": commits_limit
                },
                "ai_response": ai_response,
                "model_used": ai_service.model
            }
            
            # Add Jira ticket information if any were created
            if jira_tickets_created:
                response_data["jira_tickets_created"] = jira_tickets_created
            
            return jsonify(response_data)
            
        except Exception as e:
            return jsonify({"error": f"Error generating AI response: {str(e)}"}), 500
            
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

# Multi-Project AI Chat endpoint for analyzing multiple connected repositories
@app.route('/api/chat/multi-project', methods=['POST'])
def chat_with_multiple_repositories():
    """
    Answer questions about multiple connected GitHub repositories using AI analysis.
    
    Request Body:
    {
        "question": "How do these projects work together?",
        "repositories": ["owner/frontend-repo", "owner/backend-repo"],
        "token": "optional_github_token",
        "branch": "optional_branch_name",
        "commits_limit": 10
    }
    """
    try:
        # Check if AI service is available
        if not ai_service:
            return jsonify({"error": "AI service not available. Please check OPENAI_API_KEY environment variable."}), 503
        
        # Get request data
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        question = data.get('question')
        repositories = data.get('repositories', [])
        token = data.get('token')
        branch = data.get('branch')
        commits_limit = data.get('commits_limit', 10)
        jira_projects = data.get('jira_projects', [])  # New: Jira project keys
        include_jira_analysis = data.get('include_jira_analysis', False)
        
        # Validate required parameters
        if not question:
            return jsonify({"error": "Question parameter is required"}), 400
        
        if not repositories and not jira_projects:
            return jsonify({"error": "At least one repository or Jira project is required"}), 400
        
        if len(repositories) > 5:
            return jsonify({"error": "Maximum 5 repositories can be analyzed at once"}), 400
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()  # Use unauthenticated access (rate limited)
        
        # Collect data from all repositories
        repositories_data = []
        all_commits_data = []
        project_connections = []
        jira_data = []
        
        for repo_name in repositories:
            try:
                # Get repository information
                repo = g.get_repo(repo_name)
                
                # Get repository metadata
                repo_data = {
                    "name": repo.name,
                    "full_name": repo.full_name,
                    "description": repo.description,
                    "url": repo.html_url,
                    "language": repo.language,
                    "languages": repo.get_languages(),
                    "stars": repo.stargazers_count,
                    "forks": repo.forks_count,
                    "watchers": repo.watchers_count,
                    "open_issues": repo.open_issues_count,
                    "created_at": repo.created_at.isoformat(),
                    "updated_at": repo.updated_at.isoformat(),
                    "pushed_at": repo.pushed_at.isoformat() if repo.pushed_at else None,
                    "default_branch": repo.default_branch,
                    "is_private": repo.private,
                    "owner": {
                        "login": repo.owner.login,
                        "type": repo.owner.type,
                        "avatar_url": repo.owner.avatar_url,
                        "url": repo.owner.html_url
                    }
                }
                repositories_data.append(repo_data)
                
                # Get commits data for this repository (optimized for performance)
                try:
                    if branch:
                        commits = repo.get_commits(sha=branch)
                    else:
                        commits = repo.get_commits()  # Default branch
                    
                    commits_data = []
                    for i, commit in enumerate(commits):
                        if i >= commits_limit:
                            break
                        
                        commit_data = {
                            "sha": commit.sha,
                            "message": commit.commit.message,
                            "author": {
                                "name": commit.commit.author.name,
                                "email": commit.commit.author.email,
                                "date": commit.commit.author.date.isoformat()
                            },
                            "committer": {
                                "name": commit.commit.committer.name,
                                "email": commit.commit.committer.email,
                                "date": commit.commit.committer.date.isoformat()
                            },
                            "url": commit.html_url,
                            "stats": {
                                "additions": commit.stats.additions if commit.stats else 0,
                                "deletions": commit.stats.deletions if commit.stats else 0,
                                "total": commit.stats.total if commit.stats else 0
                            }
                        }
                        
                        # Only get detailed file changes for the first 3 commits to reduce API calls
                        if i < 3:
                            try:
                                full_commit = repo.get_commit(commit.sha)
                                file_changes = []
                                for file in full_commit.files[:10]:  # Limit to 10 files per commit
                                    file_change = {
                                        "filename": file.filename,
                                        "status": file.status,
                                        "additions": file.additions,
                                        "deletions": file.deletions,
                                        "changes": file.changes
                                    }
                                    # Only include patch data for the first 2 commits to reduce payload size
                                    if i < 2 and hasattr(file, 'patch') and file.patch:
                                        # Truncate patch to first 500 characters to reduce size
                                        patch_content = file.patch[:500] + "..." if len(file.patch) > 500 else file.patch
                                        file_change["patch"] = patch_content
                                    file_changes.append(file_change)
                                commit_data["file_changes"] = file_changes
                            except Exception as e:
                                print(f"Warning: Could not get detailed commit info for {commit.sha}: {str(e)}")
                                # If we can't get file changes, continue without them
                                pass
                        
                        commits_data.append(commit_data)
                    
                    all_commits_data.append(commits_data)
                    
                except Exception as e:
                    print(f"Warning: Could not fetch commits for {repo_name}: {str(e)}")
                    all_commits_data.append([])
                    
            except Exception as e:
                return jsonify({"error": f"Repository not found or not accessible: {repo_name} - {str(e)}"}), 404
        
        # Process Jira projects if requested
        if include_jira_analysis and jira_integration and jira_projects:
            for project_key in jira_projects:
                try:
                    # Get Jira project history
                    project_history = jira_integration.get_project_history(project_key, days_back=30)
                    if project_history:
                        jira_data.append({
                            'project_key': project_key,
                            'history': project_history
                        })
                        
                        # Add Jira project type to analysis
                        project_types.append(f'Jira Project ({project_key})')
                        
                except Exception as e:
                    print(f"Error processing Jira project {project_key}: {str(e)}")
                    continue
        
        # Analyze project connections
        project_types = []
        for repo_data in repositories_data:
            name = (repo_data.get('name') or '').lower()
            description = (repo_data.get('description') or '').lower()
            
            if any(keyword in name or keyword in description for keyword in ['frontend', 'client', 'ui', 'react', 'vue', 'angular']):
                project_types.append('Frontend')
            elif any(keyword in name or keyword in description for keyword in ['backend', 'api', 'server', 'node', 'express', 'django', 'flask']):
                project_types.append('Backend')
            elif any(keyword in name or keyword in description for keyword in ['mobile', 'app', 'ios', 'android', 'react-native']):
                project_types.append('Mobile')
            elif any(keyword in name or keyword in description for keyword in ['database', 'db', 'sql', 'mongo']):
                project_types.append('Database')
            elif any(keyword in name or keyword in description for keyword in ['docs', 'documentation']):
                project_types.append('Documentation')
            else:
                project_types.append('Other')
        
        # Detect connections
        if 'Frontend' in project_types and 'Backend' in project_types:
            project_connections.append({
                "type": "frontend-backend",
                "description": "Frontend-Backend API Integration",
                "projects": [repo for repo, ptype in zip(repositories, project_types) if ptype in ['Frontend', 'Backend']],
                "confidence": 0.9
            })
        
        if 'Mobile' in project_types and 'Backend' in project_types:
            project_connections.append({
                "type": "mobile-backend",
                "description": "Mobile-Backend API Integration",
                "projects": [repo for repo, ptype in zip(repositories, project_types) if ptype in ['Mobile', 'Backend']],
                "confidence": 0.9
            })
        
        if 'Database' in project_types:
            project_connections.append({
                "type": "database",
                "description": "Database Integration",
                "projects": [repo for repo, ptype in zip(repositories, project_types) if ptype == 'Database'],
                "confidence": 0.8
            })
        
        # Add Jira project management connection if Jira data is available
        if jira_data:
            project_connections.append({
                "type": "project-management",
                "description": "Project Management Integration",
                "projects": [data['project_key'] for data in jira_data],
                "confidence": 0.9
            })
        
        # Use AI service to analyze multiple repositories
        try:
            ai_response = ai_service.analyze_multiple_repositories(repositories_data, all_commits_data, question, jira_data=jira_data)
            
            response_data = {
                "question": question,
                "repositories": repositories,
                "branch": branch if branch else "default",
                "analysis_data": {
                    "repositories_info": repositories_data,
                    "total_commits_analyzed": sum(len(commits) for commits in all_commits_data),
                    "commits_limit": commits_limit,
                    "project_connections": project_connections
                },
                "ai_response": ai_response,
                "model_used": ai_service.model
            }
            
            # Include Jira data in response if available
            if jira_data:
                response_data["jira_projects"] = [data['project_key'] for data in jira_data]
                response_data["jira_summary"] = {
                    "total_projects": len(jira_data),
                    "total_tickets": sum(len(data['history'].get('all_tickets', [])) for data in jira_data),
                    "recent_activity": sum(data['history'].get('ticket_statistics', {}).get('recent_activity', 0) for data in jira_data)
                }
            
            return jsonify(response_data)
            
        except Exception as e:
            return jsonify({"error": f"Error generating AI response: {str(e)}"}), 500
            
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

# Commit story endpoint - Generate a narrative story from commit history
@app.route('/api/git/commits/story', methods=['POST'])
def generate_commit_story():
    """
    Generate a narrative story from commit history using AI.
    
    Request Body:
    {
        "repository": "owner/repo",
        "branch": "main",
        "token": "optional_github_token",
        "commits_limit": 20,
        "story_style": "narrative" | "technical" | "casual"
    }
    """
    try:
        # Check if AI service is available
        if not ai_service:
            return jsonify({"error": "AI service not available. Please check OPENAI_API_KEY environment variable."}), 503
        
        # Get request data
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        repository = data.get('repository')
        branch = data.get('branch')
        token = data.get('token')
        commits_limit = data.get('commits_limit', 20)
        story_style = data.get('story_style', 'narrative')
        
        # Validate required parameters
        if not repository:
            return jsonify({"error": "Repository parameter is required"}), 400
        
        if commits_limit > 50:
            commits_limit = 50  # Limit for performance
        if commits_limit < 5:
            commits_limit = 5
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()  # Use unauthenticated access (rate limited)
        
        # Get repository
        try:
            repo = g.get_repo(repository)
        except Exception as e:
            return jsonify({"error": f"Repository not found or not accessible: {str(e)}"}), 404
        
        # Get commits data
        try:
            if branch:
                commits = repo.get_commits(sha=branch)
            else:
                commits = repo.get_commits()  # Default branch
            
            commits_data = []
            for i, commit in enumerate(commits):
                if i >= commits_limit:
                    break
                
                commit_data = {
                    "sha": commit.sha,
                    "message": commit.commit.message,
                    "author": {
                        "name": commit.commit.author.name,
                        "email": commit.commit.author.email,
                        "date": commit.commit.author.date.isoformat()
                    },
                    "committer": {
                        "name": commit.commit.committer.name,
                        "email": commit.commit.committer.email,
                        "date": commit.commit.committer.date.isoformat()
                    },
                    "url": commit.html_url,
                    "stats": {
                        "additions": commit.stats.additions if commit.stats else 0,
                        "deletions": commit.stats.deletions if commit.stats else 0,
                        "total": commit.stats.total if commit.stats else 0
                    }
                }
                
                # Get basic file changes for context (limited for performance)
                try:
                    full_commit = repo.get_commit(commit.sha)
                    file_changes = []
                    for file in full_commit.files[:5]:  # Limit to 5 files per commit
                        file_change = {
                            "filename": file.filename,
                            "status": file.status,
                            "additions": file.additions,
                            "deletions": file.deletions,
                            "changes": file.changes
                        }
                        file_changes.append(file_change)
                    commit_data["file_changes"] = file_changes
                except:
                    # If we can't get file changes, continue without them
                    pass
                
                commits_data.append(commit_data)
            
            # Get repository metadata for context
            repo_data = {
                "name": repo.name,
                "full_name": repo.full_name,
                "description": repo.description,
                "language": repo.language,
                "languages": repo.get_languages(),
                "stars": repo.stargazers_count,
                "forks": repo.forks_count,
                "created_at": repo.created_at.isoformat(),
                "updated_at": repo.updated_at.isoformat(),
                "default_branch": repo.default_branch
            }
            
            # Generate story using AI service
            try:
                story = ai_service.generate_commit_story(repo_data, commits_data, story_style)
                
                response_data = {
                    "repository": repository,
                    "branch": branch if branch else "default",
                    "story_style": story_style,
                    "total_commits_analyzed": len(commits_data),
                    "story": story,
                    "commits_data": commits_data,  # Include original data for reference
                    "repository_info": repo_data
                }
                
                return jsonify(response_data)
                
            except Exception as e:
                return jsonify({"error": f"Error generating commit story: {str(e)}"}), 500
                
        except Exception as e:
            return jsonify({"error": f"Error fetching commits: {str(e)}"}), 500
            
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

# Repository branches endpoint
@app.route('/api/git/branches', methods=['GET'])
def get_repo_branches():
    """
    Get all branches from a GitHub repository.
    Query parameters:
    - repo: Repository in format 'owner/repo' (e.g., 'microsoft/vscode')
    - token: GitHub personal access token (optional, for private repos)
    """
    try:
        repo_name = request.args.get('repo')
        token = request.args.get('token')
        
        if not repo_name:
            return jsonify({"error": "Repository parameter 'repo' is required (format: 'owner/repo')"}), 400
        
        # Initialize GitHub client
        if token:
            g = Github(token)
        else:
            g = Github()  # Use unauthenticated access (rate limited)
        
        # Get repository
        try:
            repo = g.get_repo(repo_name)
        except Exception as e:
            return jsonify({"error": f"Repository not found or not accessible: {str(e)}"}), 404
        
        # Get branches
        try:
            branches = repo.get_branches()
            branches_list = []
            
            for branch in branches:
                branch_data = {
                    "name": branch.name,
                    "protected": branch.protected,
                    "commit_sha": branch.commit.sha,
                    "commit_url": branch.commit.url
                }
                branches_list.append(branch_data)
            
            return jsonify(branches_list)
            
        except Exception as e:
            return jsonify({"error": f"Error fetching branches: {str(e)}"}), 500
            
    except Exception as e:
        return jsonify({"error": f"Unexpected error: {str(e)}"}), 500

# GitHub OAuth Authentication Endpoints
@app.route('/auth/github', methods=['GET'])
def github_login():
    """
    Initiate GitHub OAuth login
    """
    try:
        if not github_auth or not github_auth.enabled:
            return jsonify({"error": "GitHub OAuth is not configured"}), 503
        
        auth_url = github_auth.get_authorization_url()
        return jsonify({"auth_url": auth_url})
        
    except Exception as e:
        return jsonify({"error": f"Error initiating GitHub login: {str(e)}"}), 500

@app.route('/auth/callback', methods=['GET'])
def github_callback():
    """
    Handle GitHub OAuth callback
    """
    try:
        if not github_auth or not github_auth.enabled:
            return jsonify({"error": "GitHub OAuth is not configured"}), 503
        
        code = request.args.get('code')
        state = request.args.get('state')
        
        if not code or not state:
            return jsonify({"error": "Missing authorization code or state"}), 400
        
        auth_result = github_auth.handle_callback(code, state)
        
        # Redirect to frontend with success
        return redirect(f"http://localhost:5174/auth/success?token={auth_result['access_token']}")
        
    except Exception as e:
        return redirect(f"http://localhost:5174/auth/error?message={str(e)}")

@app.route('/auth/user', methods=['GET'])
def get_current_user():
    """
    Get current authenticated user information
    """
    try:
        access_token = request.headers.get('Authorization')
        if not access_token or not access_token.startswith('Bearer '):
            return jsonify({"error": "No valid access token provided"}), 401
        
        token = access_token.replace('Bearer ', '')
        
        if not github_auth or not github_auth.enabled:
            return jsonify({"error": "GitHub OAuth is not configured"}), 503
        
        if not github_auth.validate_token(token):
            return jsonify({"error": "Invalid or expired token"}), 401
        
        user_info = github_auth.get_user_info(token)
        return jsonify(user_info)
        
    except Exception as e:
        return jsonify({"error": f"Error fetching user info: {str(e)}"}), 500

@app.route('/auth/repositories', methods=['GET'])
def get_user_repositories():
    """
    Get user's repositories
    """
    try:
        access_token = request.headers.get('Authorization')
        if not access_token or not access_token.startswith('Bearer '):
            return jsonify({"error": "No valid access token provided"}), 401
        
        token = access_token.replace('Bearer ', '')
        visibility = request.args.get('visibility', 'all')
        
        if not github_auth or not github_auth.enabled:
            return jsonify({"error": "GitHub OAuth is not configured"}), 503
        
        if not github_auth.validate_token(token):
            return jsonify({"error": "Invalid or expired token"}), 401
        
        repositories = github_auth.get_user_repositories(token, visibility)
        return jsonify({
            "repositories": repositories,
            "total": len(repositories)
        })
        
    except Exception as e:
        return jsonify({"error": f"Error fetching repositories: {str(e)}"}), 500

@app.route('/auth/logout', methods=['POST'])
def logout():
    """
    Logout user and clear session
    """
    try:
        if github_auth:
            github_auth.logout()
        return jsonify({"message": "Logged out successfully"})
    except Exception as e:
        return jsonify({"error": f"Error during logout: {str(e)}"}), 500

# Jira Integration Endpoints
@app.route('/api/integrations/jira/status', methods=['GET'])
def jira_status():
    """
    Get Jira integration status
    """
    try:
        if not jira_integration:
            return jsonify({
                "enabled": False,
                "message": "Jira integration not configured"
            })
        
        status = jira_integration.get_status()
        return jsonify(status)
    except Exception as e:
        return jsonify({"error": f"Error getting Jira status: {str(e)}"}), 500

@app.route('/api/integrations/jira/test', methods=['POST'])
def test_jira_connection():
    """
    Test Jira connection
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        is_connected = jira_integration.test_connection()
        return jsonify({
            "connected": is_connected,
            "message": "Connection successful" if is_connected else "Connection failed"
        })
    except Exception as e:
        return jsonify({"error": f"Error testing Jira connection: {str(e)}"}), 500

@app.route('/api/integrations/jira/ticket', methods=['POST'])
def create_jira_ticket():
    """
    Create a new Jira ticket
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        success = jira_integration.create_ticket(data)
        if success:
            return jsonify({"message": "Ticket created successfully"})
        else:
            return jsonify({"error": "Failed to create ticket"}), 500
    except Exception as e:
        return jsonify({"error": f"Error creating ticket: {str(e)}"}), 500

@app.route('/api/integrations/jira/ticket/<ticket_key>', methods=['GET'])
def get_jira_ticket(ticket_key):
    """
    Get Jira ticket information
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        ticket = jira_integration.get_ticket(ticket_key)
        if ticket:
            return jsonify(ticket)
        else:
            return jsonify({"error": "Ticket not found"}), 404
    except Exception as e:
        return jsonify({"error": f"Error getting ticket: {str(e)}"}), 500

@app.route('/api/integrations/jira/ticket/<ticket_key>', methods=['PUT'])
def update_jira_ticket(ticket_key):
    """
    Update Jira ticket
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        success = jira_integration.update_ticket(ticket_key, data)
        if success:
            return jsonify({"message": "Ticket updated successfully"})
        else:
            return jsonify({"error": "Failed to update ticket"}), 500
    except Exception as e:
        return jsonify({"error": f"Error updating ticket: {str(e)}"}), 500

@app.route('/api/integrations/jira/ticket/<ticket_key>/worklog', methods=['POST'])
def add_jira_worklog(ticket_key):
    """
    Add worklog entry to Jira ticket
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        time_spent = data.get('time_spent')
        comment = data.get('comment', '')
        started = data.get('started')
        
        if not time_spent:
            return jsonify({"error": "time_spent is required"}), 400
        
        success = jira_integration.add_worklog(ticket_key, time_spent, comment, started)
        if success:
            return jsonify({"message": "Worklog added successfully"})
        else:
            return jsonify({"error": "Failed to add worklog"}), 500
    except Exception as e:
        return jsonify({"error": f"Error adding worklog: {str(e)}"}), 500

@app.route('/api/integrations/jira/ticket/<ticket_key>/transition', methods=['POST'])
def transition_jira_ticket(ticket_key):
    """
    Transition Jira ticket to new status
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        transition_name = data.get('transition_name')
        if not transition_name:
            return jsonify({"error": "transition_name is required"}), 400
        
        success = jira_integration.transition_ticket(ticket_key, transition_name)
        if success:
            return jsonify({"message": f"Ticket transitioned to '{transition_name}' successfully"})
        else:
            return jsonify({"error": "Failed to transition ticket"}), 500
    except Exception as e:
        return jsonify({"error": f"Error transitioning ticket: {str(e)}"}), 500

@app.route('/api/integrations/jira/sync-commit', methods=['POST'])
def sync_commit_to_jira():
    """
    Sync GitHub commit with Jira ticket
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        commit_data = data.get('commit_data')
        ticket_key = data.get('ticket_key')
        
        if not commit_data or not ticket_key:
            return jsonify({"error": "commit_data and ticket_key are required"}), 400
        
        success = jira_integration.sync_commit_to_ticket(commit_data, ticket_key)
        if success:
            return jsonify({"message": "Commit synced to ticket successfully"})
        else:
            return jsonify({"error": "Failed to sync commit to ticket"}), 500
    except Exception as e:
        return jsonify({"error": f"Error syncing commit: {str(e)}"}), 500

@app.route('/api/integrations/jira/quality-ticket', methods=['POST'])
def create_quality_ticket():
    """
    Create Jira ticket for code quality issues
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        analysis_data = data.get('analysis_data')
        project_key = data.get('project_key')
        
        if not analysis_data:
            return jsonify({"error": "analysis_data is required"}), 400
        
        success = jira_integration.create_quality_ticket(analysis_data, project_key)
        if success:
            return jsonify({"message": "Quality ticket created successfully"})
        else:
            return jsonify({"error": "Failed to create quality ticket"}), 500
    except Exception as e:
        return jsonify({"error": f"Error creating quality ticket: {str(e)}"}), 500

@app.route('/api/integrations/jira/search', methods=['POST'])
def search_jira_tickets():
    """
    Search Jira tickets using JQL
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        jql = data.get('jql')
        max_results = data.get('max_results', 50)
        
        if not jql:
            return jsonify({"error": "jql is required"}), 400
        
        tickets = jira_integration.search_tickets(jql, max_results)
        return jsonify({
            "tickets": tickets,
            "count": len(tickets)
        })
    except Exception as e:
        return jsonify({"error": f"Error searching tickets: {str(e)}"}), 500

@app.route('/api/integrations/jira/project-history', methods=['GET'])
def get_jira_project_history():
    """
    Get Jira project history and provide AI-powered analysis
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        # Get query parameters
        project_key = request.args.get('project_key', 'COMM')
        days_back = int(request.args.get('days_back', 30))
        
        # Get project history from Jira
        project_history = jira_integration.get_project_history(project_key, days_back)
        
        if not project_history:
            return jsonify({"error": "Failed to retrieve project history"}), 500
        
        return jsonify({
            "message": "Project history retrieved successfully",
            "project_key": project_key,
            "analysis_period": project_history.get('analysis_period'),
            "ticket_statistics": project_history.get('ticket_statistics'),
            "breakdown": project_history.get('breakdown'),
            "recent_tickets": project_history.get('recent_tickets', [])[:10]  # Limit recent tickets
        })
        
    except Exception as e:
        return jsonify({"error": f"Error retrieving project history: {str(e)}"}), 500

@app.route('/api/integrations/jira/projects', methods=['GET'])
def get_available_jira_projects():
    """
    Get list of available Jira projects for analysis
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        # This would typically query Jira for available projects
        # For now, return a demo list
        demo_projects = [
            {"key": "COMM", "name": "Commet Project", "description": "Main project management"},
            {"key": "DEV", "name": "Development", "description": "Development tasks and features"},
            {"key": "BUG", "name": "Bug Tracking", "description": "Bug reports and fixes"},
        ]
        
        return jsonify({
            "message": "Available Jira projects",
            "projects": demo_projects
        })
        
    except Exception as e:
        return jsonify({"error": f"Error getting Jira projects: {str(e)}"}), 500

@app.route('/api/integrations/jira/project-analysis', methods=['POST'])
def analyze_jira_project():
    """
    Get AI-powered analysis of Jira project history
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        if not ai_service:
            return jsonify({"error": "AI service not available"}), 503
        
        # Get request data
        data = request.get_json() or {}
        project_key = data.get('project_key', 'COMM')
        days_back = data.get('days_back', 30)
        
        # Get project history from Jira
        project_history = jira_integration.get_project_history(project_key, days_back)
        
        if not project_history:
            return jsonify({"error": "Failed to retrieve project history"}), 500
        
        # Generate AI analysis
        ai_analysis = ai_service.analyze_jira_project_history(project_history)
        
        return jsonify({
            "message": "Project analysis completed successfully",
            "project_key": project_key,
            "analysis_period": project_history.get('analysis_period'),
            "ticket_statistics": project_history.get('ticket_statistics'),
            "breakdown": project_history.get('breakdown'),
            "ai_analysis": ai_analysis,
            "model_used": ai_service.model
        })
        
    except Exception as e:
        return jsonify({"error": f"Error analyzing project: {str(e)}"}), 500

@app.route('/api/demo/create-tickets', methods=['POST'])
def create_demo_tickets():
    """
    Create demo Jira tickets for the local repository analysis
    """
    try:
        if not jira_integration:
            return jsonify({"error": "Jira integration not configured"}), 400
        
        # Demo issues detected in the local repository
        demo_issues = [
            {
                "title": "SQL Injection Vulnerability in User Authentication",
                "description": """**Security Issue Detected by Commet AI**

**File**: security-issue.js, line 4
**Function**: getUserData(userId)

**Issue**: Direct string interpolation in SQL query
```javascript
const query = `SELECT * FROM users WHERE id = ${userId}`;
return mysql.query(query);
```

**Risk Level**: HIGH
**Impact**: Allows arbitrary SQL execution, potential data breach

**Recommendation**: Use parameterized queries:
```javascript
const query = 'SELECT * FROM users WHERE id = ?';
return mysql.query(query, [userId]);
```

**Labels**: commet-analysis, security, severity-high""",
                "priority": "High",
                "labels": ["commet-analysis", "security", "severity-high"]
            },
            {
                "title": "Hardcoded Credentials in Source Code",
                "description": """**Security Issue Detected by Commet AI**

**File**: security-issue.js, lines 8-9

**Issue**: API keys and passwords hardcoded in source code
```javascript
const DB_PASSWORD = "admin123";
const API_KEY = "sk-1234567890abcdef";
```

**Risk Level**: HIGH
**Impact**: Credential exposure, unauthorized access

**Recommendation**: Use environment variables:
```javascript
const DB_PASSWORD = process.env.DB_PASSWORD;
const API_KEY = process.env.API_KEY;
```

**Labels**: commet-analysis, security, credentials""",
                "priority": "High",
                "labels": ["commet-analysis", "security", "credentials"]
            },
            {
                "title": "Dangerous Eval Usage in User Input Processing",
                "description": """**Critical Security Issue Detected by Commet AI**

**File**: security-issue.js, line 13
**Function**: processUserInput(input)

**Issue**: Direct eval() execution of user input
```javascript
function processUserInput(input) {
  return eval(input); // Dangerous eval usage
}
```

**Risk Level**: CRITICAL
**Impact**: Code injection, complete system compromise

**Recommendation**: Remove eval() usage entirely:
```javascript
function processUserInput(input) {
  // Use safe parsing methods instead
  return JSON.parse(input);
}
```

**Labels**: commet-analysis, security, code-injection""",
                "priority": "Critical",
                "labels": ["commet-analysis", "security", "code-injection"]
            },
            {
                "title": "Memory Leak in Global Data Array",
                "description": """**Performance Issue Detected by Commet AI**

**File**: performance-issue.js, lines 4-7

**Issue**: Global array that never gets cleared
```javascript
let globalData = [];
function addToGlobal(data) {
  globalData.push(data); // Never cleared - memory leak
}
```

**Risk Level**: MEDIUM
**Impact**: Memory consumption grows indefinitely

**Recommendation**: Implement cleanup mechanism:
```javascript
function addToGlobal(data) {
  globalData.push(data);
  // Add cleanup logic
  if (globalData.length > MAX_SIZE) {
    globalData = globalData.slice(-MAX_SIZE);
  }
}
```

**Labels**: commet-analysis, performance, memory-leak""",
                "priority": "Medium",
                "labels": ["commet-analysis", "performance", "memory-leak"]
            },
            {
                "title": "Inefficient Loop with 1M Iterations",
                "description": """**Performance Issue Detected by Commet AI**

**File**: performance-issue.js, lines 1-6

**Issue**: Inefficient loop with heavy computation
```javascript
function inefficientLoop() {
  const data = [];
  for (let i = 0; i < 1000000; i++) {
    data.push(i * Math.random()); // Inefficient memory usage
  }
  return data;
}
```

**Risk Level**: MEDIUM
**Impact**: High CPU usage, potential UI blocking

**Recommendation**: Optimize with batch processing:
```javascript
function efficientLoop() {
  const data = new Array(1000000);
  for (let i = 0; i < 1000000; i++) {
    data[i] = i * Math.random();
  }
  return data;
}
```

**Labels**: commet-analysis, performance, optimization""",
                "priority": "Medium",
                "labels": ["commet-analysis", "performance", "optimization"]
            }
        ]
        
        created_tickets = []
        
        for issue in demo_issues:
            try:
                ticket_data = {
                    "fields": {
                        "project": {"key": "COMM"},
                        "summary": issue["title"],
                        "description": issue["description"],
                        "issuetype": {"name": "Bug"},
                        "priority": {"name": issue["priority"]},
                        "labels": issue["labels"]
                    }
                }
                
                ticket = jira_integration.create_ticket(ticket_data)
                created_tickets.append({
                    "key": ticket.key,
                    "title": issue["title"],
                    "priority": issue["priority"],
                    "url": f"https://faikbairamov0.atlassian.net/browse/{ticket.key}"
                })
                
            except Exception as e:
                print(f"Error creating ticket '{issue['title']}': {str(e)}")
        
        return jsonify({
            "message": f"Demo tickets created successfully",
            "tickets_created": len(created_tickets),
            "tickets": created_tickets
        })
        
    except Exception as e:
        return jsonify({"error": f"Error creating demo tickets: {str(e)}"}), 500

@app.route('/webhooks/jira', methods=['POST'])
def jira_webhook():
    """
    Handle Jira webhooks
    """
    try:
        if not jira_webhook_handler:
            return jsonify({"error": "Jira webhook handler not configured"}), 400
        
        payload = request.get_json()
        if not payload:
            return jsonify({"error": "Request body must be JSON"}), 400
        
        result = jira_webhook_handler.handle_webhook(payload)
        return jsonify(result)
        
    except Exception as e:
        return jsonify({"error": f"Error handling Jira webhook: {str(e)}"}), 500

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Endpoint not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

if __name__ == '__main__':
    # Get port from environment variable (Railway sets this)
    port = int(os.getenv('PORT', 3000))
    debug = os.getenv('FLASK_ENV') != 'production'
    
    print("Starting Python server on port {}...".format(port))
    print("Visit http://localhost:{} to see the server in action".format(port))
    print("API endpoints available:")
    print("  GET  / - Home page")
    print("  GET  /health - Health check")
    print("  GET  /api/users - Get all users")
    print("  POST /api/users - Create a new user")
    print("  GET  /api/git/commits - Get git commits from GitHub repo")
    print("  GET  /api/git/commit-details - Get git commits with code differences")
    print("  GET  /api/git/repo - Get GitHub repository information")
    print("  POST /api/chat - AI-powered repository analysis and Q&A")
    print("  GET  /auth/github - Initiate GitHub OAuth login")
    print("  GET  /auth/callback - GitHub OAuth callback")
    print("  GET  /auth/user - Get current user info")
    print("  GET  /auth/repositories - Get user repositories")
    print("  POST /auth/logout - Logout user")
    print("  Jira Integration Endpoints:")
    print("    GET  /api/integrations/jira/status - Get Jira integration status")
    print("    POST /api/integrations/jira/test - Test Jira connection")
    print("    POST /api/integrations/jira/ticket - Create Jira ticket")
    print("    GET  /api/integrations/jira/ticket/<key> - Get Jira ticket")
    print("    PUT  /api/integrations/jira/ticket/<key> - Update Jira ticket")
    print("    POST /api/integrations/jira/ticket/<key>/worklog - Add worklog")
    print("    POST /api/integrations/jira/ticket/<key>/transition - Transition ticket")
    print("    POST /api/integrations/jira/sync-commit - Sync commit to ticket")
    print("    POST /api/integrations/jira/quality-ticket - Create quality ticket")
    print("    POST /api/integrations/jira/search - Search tickets with JQL")
    print("    POST /webhooks/jira - Handle Jira webhooks")
    
    app.run(host='0.0.0.0', port=port, debug=debug)
